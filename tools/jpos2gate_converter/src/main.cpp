/// @file main.cpp
/// @author Rafal Maselek <rafalmaselek@gmail.com>
/// @date 15.02.2018
/// @version 1.0
///
/// @section DESCRIPTION
/// Main function of the program. Contains functions that allow to convert jpos root output file to Gate root
/// output and vice versa.
///
/// @section USAGE
/// Use convert.py python script. 
/// python convert.py [input file path] [output file name] [1 for jpos->gate conversion, 0 gate->jpos]

#include "MyGateOutput.h"
#include "MyJPOSOutput.h"
#include "event.h"
#include <iostream>
///
/// \brief jpos2gate Converts root file generated by jpos into root file wich has the same format as Gate output.
/// \param file TFile* pointer to an object representing the output file.
///
void jpos2gate(TFile* file)
{
    // declare fields like in a Hits tree inside Gate output file
    int           PDGEncoding=22;
    int           trackID = 0;
    int           parentID = 0;
    double        time = 0.0;
    float         edep = 0.0;
    float         stepLength = 0.0;
    float         posX = 0.0;
    float         posY = 0.0;
    float         posZ = 0.0;
    float         localPosX = 0.0;
    float         localPosY = 0.0;
    float         localPosZ = 0.0;
    int           baseID = 0;
    int           level1ID = 0;
    int           level2ID = 0;
    int           level3ID = 0;
    int           level4ID = 0;
    int           layerID = 0;
    int           photonID = 0;
    int           nPhantomCompton = 0;
    int           nCrystalCompton = 0;
    int           nPhantomRayleigh = 0;
    int           nCrystalRayleigh = 0;
    int           primaryID = 0;
    float         sourcePosX =0.0;
    float         sourcePosY = 0.0;
    float         sourcePosZ = 0.0;
    int           sourceID = 0;
    int           eventID = 0;
    int           runID = 0;
    float         axialPos = 0.0;
    float         rotationAngle = 0.0;
    int           volumeID[10] = {0,0,0,0,0,0,0,0};
    char          processName[8] = "Compton";
    char          comptVolName[5] = "NULL";
    char          RayleighVolName[5] = "NULL";

    // create input object and load data
    MyJPOSOutput my_jpos_out;
    my_jpos_out.Loop();

    // assign branches
    file->cd();
    TTree* Hits = new TTree("Hits", "Hits");
    Hits->Branch("PDGEncoding", &PDGEncoding,"PDGEncoding/I");
    Hits->Branch("trackID", &trackID,"trackID/I");
    Hits->Branch("parentID", &parentID,"parentID/I");
    Hits->Branch("time", &time,"time/D");
    Hits->Branch("edep", &edep,"edep/F");
    Hits->Branch("stepLength", &stepLength,"stepLength/F");
    Hits->Branch("posX", &posX,"posX/F");
    Hits->Branch("posY", &posY,"posY/F");
    Hits->Branch("posZ", &posZ,"posZ/F");
    Hits->Branch("localPosX", &localPosX,"localPosX/F");
    Hits->Branch("localPosY", &localPosY,"localPosY/F");
    Hits->Branch("localPosZ", &localPosZ,"localPosZ/F");
    Hits->Branch("baseID", &baseID,"baseID/I");
    Hits->Branch("level1ID", &level1ID,"level1ID/I");
    Hits->Branch("level2ID", &level2ID,"level2ID/I");
    Hits->Branch("level3ID", &level3ID,"level3ID/I");
    Hits->Branch("level4ID", &level4ID,"level4ID/I");
    Hits->Branch("layerID", &layerID,"layerID/I");
    Hits->Branch("photonID", &photonID,"photonID/I");
    Hits->Branch("nPhantomCompton", &nPhantomCompton,"nPhantomCompton/I");
    Hits->Branch("nCrystalCompton", &nCrystalCompton,"nCrystalCompton/I");
    Hits->Branch("nPhantomRayleigh", &nPhantomRayleigh,"nPhantomRayleigh/I");
    Hits->Branch("nCrystalRayleigh", &nCrystalRayleigh,"nCrystalRayleigh/I");
    Hits->Branch("primaryID", &primaryID,"primaryID/I");
    Hits->Branch("sourcePosX", &sourcePosX,"sourcePosX/F");
    Hits->Branch("sourcePosY", &sourcePosY,"sourcePosY/F");
    Hits->Branch("sourcePosZ", &sourcePosZ,"sourcePosZ/F");
    Hits->Branch("sourceID", &sourceID,"sourceID/I");
    Hits->Branch("eventID", &eventID,"eventID/I");
    Hits->Branch("runID", &runID,"runID/I");
    Hits->Branch("axialPos", &axialPos,"axialPos/F");
    Hits->Branch("rotationAngle", &rotationAngle,"rotationAngle/F");
    Hits->Branch("volumeID", &volumeID,"volumeID[10]/I");
    Hits->Branch("processName", &processName,"processName[8]/C");
    Hits->Branch("comptVolName", &comptVolName,"comptVolName[5]/C");
    Hits->Branch("RayleighVolName", &RayleighVolName,"RayleighVolName[5]/C");

    Hits->SetAutoSave(10e6);
    // Writing data
    std::cout<<"[SAVING DATA]"<<std::endl;
    for(int eventNo = 0; eventNo<my_jpos_out.entries; eventNo++)
    {
      for(int particleNo=0; particleNo<5; particleNo++)
      {
        if(my_jpos_out.CutPassing[eventNo].size() > (unsigned long)particleNo && my_jpos_out.CutPassing[eventNo][particleNo])
        {
          time = my_jpos_out.EmissionPoint[eventNo][particleNo].T();
          sourcePosX = my_jpos_out.EmissionPoint[eventNo][particleNo].X();
          sourcePosY= my_jpos_out.EmissionPoint[eventNo][particleNo].Y();
          sourcePosZ = my_jpos_out.EmissionPoint[eventNo][particleNo].Z();
          posX = my_jpos_out.HitPoint[eventNo][particleNo].X();
          posY = my_jpos_out.HitPoint[eventNo][particleNo].Y();
          posZ = my_jpos_out.HitPoint[eventNo][particleNo].Z();
          edep = my_jpos_out.EdepSmear[eventNo][particleNo];
          if(edep<0.0) edep = 0.0;
          eventID = my_jpos_out.Id[eventNo];
          Hits->Fill();
          if( (double)eventNo/my_jpos_out.entries * 100 - (int)((double)eventNo/my_jpos_out.entries * 100) < 100.0/my_jpos_out.entries)
          {
                std::cout<<"["<<eventNo*100/my_jpos_out.entries<<"\% SAVED]"<<std::endl;
          }
        }
        else
          break;
      }  	
    }
   	Hits->Write();
    std::cout<<"[DATA SAVED]"<<std::endl;

}

///
/// \brief gate2jpos Function that converts a root file with Gate output to a root file with jpos-like output.
/// \param file TFile* pointer to an object representing an output file.
///
void gate2jpos(TFile* file)
{  	
    // creating input object and loading data
    MyGateOutput mygate;
    mygate.Loop();
    int decayType = 4;

    file->cd();
    file->mkdir("0_0_0_0_0_0/");
    file->cd("0_0_0_0_0_0/");

    TTree* tree = new TTree("tree", "tree");
    tree->SetAutoSave(10e6);

    std::cout<<"[SAVING DATA]"<<std::endl;
    for(int eventNo = 0; eventNo<mygate.events; eventNo++)
    {      
        std::vector<bool> cutPassing;
        for(int ii=0; (unsigned int)ii<mygate.primaryPhotons[eventNo].size(); ii++)
        {
            cutPassing.push_back(true);
        }
        // Saving data
        Event event(mygate.emissionPoints[eventNo], mygate.hits[eventNo], mygate.fourMomenta[eventNo],\
        mygate.hitPhi[eventNo], mygate.hitTheta[eventNo], cutPassing, mygate.primaryPhotons[eventNo],\
        mygate.edepVec[eventNo], mygate.edepSmearVec[eventNo], mygate.ids[eventNo], decayType);
        tree->Branch("event_split", "Event", &event, 32000, 99);
        tree->Fill();
        if( (double)eventNo/mygate.events * 100 - (int)((double)eventNo/mygate.events * 100) < 100.0/mygate.events)
        {
            std::cout<<"["<<eventNo*100/mygate.events<<"\% SAVED]"<<std::endl;
        }
    }
    tree->Write();
    std::cout<<"[DATA SAVED]"<<std::endl;
}

///
/// \brief main Main function of the program, launches gate2jpos or jpos2gate depending on the provided arguments.
/// \param argc Number of provided arguments + 1 (name of the program).
/// \param argv Array with provided arguments (argv[0] contains name of the program).
/// \return nothing
///
int main (int argc, char* argv[])
{
    char* out_file = "output.root";
    bool jpos_to_goja = true;

    if(argc>1)
    {
        out_file = argv[1];
        jpos_to_goja = (bool)atoi(argv[2]);
    }

    TFile* file = new TFile(out_file, "recreate");
    if(jpos_to_goja)
        jpos2gate(file);
    else
        gate2jpos(file);

    if(file)
    {
        file->Write();
        file->Close();
        delete file;
    }
}
